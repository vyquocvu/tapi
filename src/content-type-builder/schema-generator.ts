/**
 * Prisma Schema Generator
 * Converts content type definitions to Prisma schema
 */

import {
  ContentTypeDefinition,
  ContentTypeRegistry,
  Field,
  GeneratedSchema,
} from './types.js'

export class PrismaSchemaGenerator {
  /**
   * Generate Prisma schema from content type definitions
   */
  generate(contentTypes: ContentTypeRegistry): GeneratedSchema {
    const models: string[] = []
    const modelNames: string[] = []
    
    // System models that should not be generated from content types
    const systemModels = ['User', 'Post']

    // First pass: generate all models
    for (const contentType of Object.values(contentTypes)) {
      const modelName = this.getModelName(contentType)
      
      // Skip system models that are already defined
      if (systemModels.includes(modelName)) {
        console.log(`⚠️  Skipping ${modelName} - already defined in system tables`)
        continue
      }
      
      const modelSchema = this.generateModel(contentType, contentTypes)
      models.push(modelSchema)
      modelNames.push(modelName)
    }

    // Combine into full schema
    const prismaSchema = this.generateFullSchema(models)

    return {
      prismaSchema,
      models: modelNames,
      migrations: [], // Migrations will be handled separately
    }
  }

  /**
   * Generate full Prisma schema with header and system tables
   */
  private generateFullSchema(models: string[]): string {
    // Allow provider to be configured via environment variable (default: sqlite for dev)
    const provider = process.env.DATABASE_PROVIDER || 'sqlite'
    
    const header = `// This file is auto-generated by the Content Type Builder
// Do not edit manually
// System tables are defined in prisma/schema.original.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "${provider}"
  url      = env("DATABASE_URL")
}

// =============================================================================
// SYSTEM TABLES - Core authentication and CMS infrastructure
// These tables are NOT managed by the Content Type Builder
// =============================================================================

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String   // Hashed password
  name      String
  bio       String?  // User biography
  avatar    String?  // Avatar image URL
  isActive  Boolean  @default(true) // Account status
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  posts              Post[]
  articles           Article[]
  createdRevisions   ContentRevision[] @relation("RevisionCreator")
  createdMetadata    ContentMetadata[] @relation("MetadataCreator")
  userRoles          UserRole[]
  userPermissions    UserPermission[]
  auditLogs          AuditLog[]
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  body      String
  published Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
}

// =============================================================================
// CMS METADATA TABLES - Enhanced content management features
// These tables support ANY content type defined in the CMS
// =============================================================================

// ContentMetadata: SEO and metadata for any content type
model ContentMetadata {
  id            Int      @id @default(autoincrement())
  contentType   String   // e.g., "api::article.article", "api::product.product"
  contentId     Int      // ID of the actual content record
  
  // SEO fields
  metaTitle     String?
  metaDescription String?
  metaKeywords  String?
  ogTitle       String?  // Open Graph title
  ogDescription String?  // Open Graph description
  ogImage       String?  // Open Graph image URL
  
  // Additional metadata (stored as JSON for flexibility)
  customData    String?  // JSON string for SQLite compatibility
  
  // Tracking
  createdById   Int
  createdBy     User     @relation("MetadataCreator", fields: [createdById], references: [id])
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Unique constraint: one metadata record per content item
  @@unique([contentType, contentId])
  @@index([contentType])
  @@index([contentId])
}

// ContentRevision: Audit trail and version history for any content type
model ContentRevision {
  id            Int      @id @default(autoincrement())
  contentType   String   // e.g., "api::article.article"
  contentId     Int      // ID of the actual content record
  
  // Revision data
  revisionNumber Int     // Sequential version number for this content
  data          String   // Full snapshot as JSON string for SQLite compatibility
  changeLog     String?  // Optional description of what changed
  
  // Tracking
  createdById   Int
  createdBy     User     @relation("RevisionCreator", fields: [createdById], references: [id])
  createdAt     DateTime @default(now())
  
  @@unique([contentType, contentId, revisionNumber])
  @@index([contentType, contentId])
  @@index([createdAt])
}

// ContentTag: Flexible tagging system for any content type
model ContentTag {
  id          Int      @id @default(autoincrement())
  name        String   @unique // Tag name (e.g., "featured", "urgent", "beginner")
  slug        String   @unique // URL-friendly version
  description String?  // Optional tag description
  color       String?  // Optional color for UI display (e.g., "#FF5733")
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  taggedContent ContentTagRelation[]
}

// ContentTagRelation: Many-to-many relation between tags and any content
model ContentTagRelation {
  id          Int      @id @default(autoincrement())
  tagId       Int
  contentType String   // e.g., "api::article.article"
  contentId   Int      // ID of the actual content record
  
  tag         ContentTag @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  
  @@unique([tagId, contentType, contentId])
  @@index([contentType, contentId])
  @@index([tagId])
}

// ContentRelation: Generic relationship between any two content items
// Useful for features like "related articles", "recommended products", etc.
model ContentRelation {
  id               Int      @id @default(autoincrement())
  sourceType       String   // Content type of the source
  sourceId         Int      // ID of the source content
  targetType       String   // Content type of the target
  targetId         Int      // ID of the target content
  relationType     String   // Type of relation (e.g., "related", "parent", "child")
  
  createdAt        DateTime @default(now())
  
  @@unique([sourceType, sourceId, targetType, targetId, relationType])
  @@index([sourceType, sourceId])
  @@index([targetType, targetId])
}

// =============================================================================
// RBAC TABLES - Role-Based Access Control
// =============================================================================

// Role: Defines user roles like Admin, Editor, Viewer, etc.
model Role {
  id          Int      @id @default(autoincrement())
  name        String   @unique // e.g., "Admin", "Editor", "Viewer"
  description String?  // Description of the role
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  userRoles       UserRole[]
  rolePermissions RolePermission[]
}

// Permission: Defines specific permissions
model Permission {
  id          Int      @id @default(autoincrement())
  name        String   @unique // e.g., "users:create", "posts:edit", "content:delete"
  resource    String   // Resource type: "users", "posts", "content", "roles", "permissions"
  action      String   // Action: "create", "read", "update", "delete", "manage"
  description String?  // Description of the permission
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  rolePermissions RolePermission[]
  userPermissions UserPermission[]
  
  @@index([resource])
  @@index([action])
}

// UserRole: Many-to-many relationship between users and roles
model UserRole {
  id         Int      @id @default(autoincrement())
  userId     Int
  roleId     Int
  assignedAt DateTime @default(now())
  assignedBy Int?     // User ID who assigned this role
  
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role       Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
}

// RolePermission: Many-to-many relationship between roles and permissions
model RolePermission {
  id           Int        @id @default(autoincrement())
  roleId       Int
  permissionId Int
  assignedAt   DateTime   @default(now())
  
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  
  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

// UserPermission: Direct permissions assigned to users (overrides role permissions)
model UserPermission {
  id           Int        @id @default(autoincrement())
  userId       Int
  permissionId Int
  assignedAt   DateTime   @default(now())
  assignedBy   Int?       // User ID who assigned this permission
  
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  
  @@unique([userId, permissionId])
  @@index([userId])
  @@index([permissionId])
}

// AuditLog: Tracks all changes to users, roles, and permissions
model AuditLog {
  id          Int      @id @default(autoincrement())
  userId      Int?     // User who performed the action
  action      String   // Action performed: "create", "update", "delete", "assign", "revoke"
  resource    String   // Resource affected: "user", "role", "permission", "user_role", etc.
  resourceId  Int?     // ID of the affected resource
  details     String?  // Additional details about the change (JSON string for SQLite compatibility)
  ipAddress   String?  // IP address of the user
  userAgent   String?  // User agent string
  createdAt   DateTime @default(now())
  
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@index([userId])
  @@index([resource])
  @@index([createdAt])
}

// =============================================================================
// CUSTOM CONTENT TYPES - Defined via Content Type Builder
// =============================================================================

`

    return header + models.join('\n\n')
  }

  /**
   * Generate a single Prisma model
   */
  private generateModel(contentType: ContentTypeDefinition, registry: ContentTypeRegistry): string {
    const modelName = this.getModelName(contentType)
    const tableName = contentType.options?.tableName || contentType.pluralName

    let schema = `model ${modelName} {\n`

    // Add id field (always present)
    schema += `  id        Int      @id @default(autoincrement())\n`

    // Add custom fields
    for (const [fieldName, field] of Object.entries(contentType.fields)) {
      const fieldSchema = this.generateField(fieldName, field, contentType, registry)
      if (fieldSchema) {
        schema += fieldSchema
      }
    }

    // Add timestamps if enabled (default: true)
    if (contentType.options?.timestamps !== false) {
      schema += `  createdAt DateTime @default(now())\n`
      schema += `  updatedAt DateTime @updatedAt\n`
    }

    // Add soft delete if enabled
    if (contentType.options?.softDelete) {
      schema += `  deletedAt DateTime?\n`
    }

    schema += `\n`

    // Add table name mapping if custom
    if (contentType.options?.tableName) {
      schema += `  @@map("${tableName}")\n`
    }

    schema += `}`

    return schema
  }

  /**
   * Generate a field definition
   */
  private generateField(
    fieldName: string,
    field: Field,
    contentType: ContentTypeDefinition,
    registry: ContentTypeRegistry
  ): string {
    switch (field.type) {
      case 'string':
      case 'email':
      case 'password':
      case 'uid':
        return this.generateStringField(fieldName, field)
      case 'text':
      case 'richtext':
        return this.generateTextField(fieldName, field)
      case 'integer':
        return this.generateIntField(fieldName, field)
      case 'biginteger':
        return this.generateBigIntField(fieldName, field)
      case 'float':
      case 'decimal':
        return this.generateFloatField(fieldName, field)
      case 'boolean':
        return this.generateBooleanField(fieldName, field)
      case 'date':
      case 'datetime':
        return this.generateDateField(fieldName, field)
      case 'time':
        return this.generateTimeField(fieldName, field)
      case 'json':
        return this.generateJsonField(fieldName, field)
      case 'enumeration':
        return this.generateEnumField(fieldName, field, contentType)
      case 'relation':
        return this.generateRelationField(fieldName, field, contentType, registry)
      default: {
        const exhaustiveCheck: never = field
        console.warn(`Unknown field type: ${(exhaustiveCheck as any).type}`)
        return ''
      }
    }
  }

  private generateStringField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const unique = field.unique ? ' @unique' : ''
    const defaultValue = field.default ? ` @default("${field.default}")` : ''
    return `  ${fieldName}  String${optional}${unique}${defaultValue}\n`
  }

  private generateTextField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const defaultValue = field.default ? ` @default("${field.default}")` : ''
    return `  ${fieldName}  String${optional}${defaultValue}\n`
  }

  private generateIntField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const unique = field.unique ? ' @unique' : ''
    const defaultValue = field.default !== undefined ? ` @default(${field.default})` : ''
    return `  ${fieldName}  Int${optional}${unique}${defaultValue}\n`
  }

  private generateBigIntField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const unique = field.unique ? ' @unique' : ''
    const defaultValue = field.default !== undefined ? ` @default(${field.default})` : ''
    return `  ${fieldName}  BigInt${optional}${unique}${defaultValue}\n`
  }

  private generateFloatField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const defaultValue = field.default !== undefined ? ` @default(${field.default})` : ''
    return `  ${fieldName}  Float${optional}${defaultValue}\n`
  }

  private generateBooleanField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const defaultValue = field.default !== undefined ? ` @default(${field.default})` : ''
    return `  ${fieldName}  Boolean${optional}${defaultValue}\n`
  }

  private generateDateField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const defaultValue =
      field.default === 'now' ? ' @default(now())' : field.default ? ` @default(${field.default})` : ''
    return `  ${fieldName}  DateTime${optional}${defaultValue}\n`
  }

  private generateTimeField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    return `  ${fieldName}  DateTime${optional}\n`
  }

  private generateJsonField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    return `  ${fieldName}  Json${optional}\n`
  }

  private generateEnumField(fieldName: string, field: Field, contentType: ContentTypeDefinition): string {
    if (field.type !== 'enumeration') return ''

    const enumName = this.capitalize(this.getModelName(contentType)) + this.capitalize(fieldName)
    const optional = !field.required ? '?' : ''
    const defaultValue = field.default ? ` @default(${field.default})` : ''

    // Note: Enums need to be defined separately in Prisma
    return `  ${fieldName}  ${enumName}${optional}${defaultValue}\n`
  }

  private generateRelationField(
    fieldName: string,
    field: Field,
    contentType: ContentTypeDefinition,
    registry: ContentTypeRegistry
  ): string {
    if (field.type !== 'relation') return ''

    const targetModel = this.getModelNameFromUid(field.target, registry)
    const relationType = field.relationType

    switch (relationType) {
      case 'oneToOne':
        return this.generateOneToOneRelation(fieldName, field, targetModel)
      case 'oneToMany':
        return this.generateOneToManyRelation(fieldName, field, targetModel)
      case 'manyToOne':
        return this.generateManyToOneRelation(fieldName, field, targetModel, contentType)
      case 'manyToMany':
        return this.generateManyToManyRelation(fieldName, field, targetModel)
      default:
        return ''
    }
  }

  private generateOneToOneRelation(fieldName: string, field: Field, targetModel: string): string {
    const optional = !field.required ? '?' : ''
    return `  ${fieldName}   ${targetModel}${optional}\n`
  }

  private generateOneToManyRelation(fieldName: string, _field: Field, targetModel: string): string {
    return `  ${fieldName}   ${targetModel}[]\n`
  }

  private generateManyToOneRelation(
    fieldName: string,
    field: Field,
    targetModel: string,
    _contentType: ContentTypeDefinition
  ): string {
    const foreignKeyName = `${fieldName}Id`
    const optional = !field.required ? '?' : ''

    let schema = `  ${foreignKeyName} Int${optional}\n`
    schema += `  ${fieldName}   ${targetModel}${optional} @relation(fields: [${foreignKeyName}], references: [id])\n`

    return schema
  }

  private generateManyToManyRelation(fieldName: string, _field: Field, targetModel: string): string {
    return `  ${fieldName}   ${targetModel}[]\n`
  }

  /**
   * Get Prisma model name from content type
   */
  private getModelName(contentType: ContentTypeDefinition): string {
    return this.capitalize(contentType.singularName)
  }

  /**
   * Get model name from UID
   */
  private getModelNameFromUid(uid: string, registry: ContentTypeRegistry): string {
    const contentType = registry[uid]
    if (!contentType) {
      throw new Error(`Content type with uid ${uid} not found`)
    }
    return this.getModelName(contentType)
  }

  /**
   * Capitalize first letter
   */
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }

  /**
   * Generate enum definitions for all enumeration fields
   */
  generateEnums(contentTypes: ContentTypeRegistry): string {
    const enums: string[] = []

    for (const contentType of Object.values(contentTypes)) {
      for (const [fieldName, field] of Object.entries(contentType.fields)) {
        if (field.type === 'enumeration') {
          const enumName = this.capitalize(this.getModelName(contentType)) + this.capitalize(fieldName)
          let enumDef = `enum ${enumName} {\n`

          for (const value of field.values) {
            enumDef += `  ${value}\n`
          }

          enumDef += `}`
          enums.push(enumDef)
        }
      }
    }

    return enums.length > 0 ? '\n' + enums.join('\n\n') + '\n' : ''
  }
}

export const prismaSchemaGenerator = new PrismaSchemaGenerator()
