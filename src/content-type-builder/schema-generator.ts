/**
 * Prisma Schema Generator
 * Converts content type definitions to Prisma schema
 */

import {
  ContentTypeDefinition,
  ContentTypeRegistry,
  Field,
  GeneratedSchema,
} from './types.js'

export class PrismaSchemaGenerator {
  /**
   * Generate Prisma schema from content type definitions
   */
  generate(contentTypes: ContentTypeRegistry): GeneratedSchema {
    const models: string[] = []
    const modelNames: string[] = []

    // First pass: generate all models
    for (const contentType of Object.values(contentTypes)) {
      const modelSchema = this.generateModel(contentType, contentTypes)
      models.push(modelSchema)
      modelNames.push(this.getModelName(contentType))
    }

    // Combine into full schema
    const prismaSchema = this.generateFullSchema(models)

    return {
      prismaSchema,
      models: modelNames,
      migrations: [], // Migrations will be handled separately
    }
  }

  /**
   * Generate full Prisma schema with header
   */
  private generateFullSchema(models: string[]): string {
    const header = `// This file is auto-generated by the Content Type Builder
// Do not edit manually

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

`

    return header + models.join('\n\n')
  }

  /**
   * Generate a single Prisma model
   */
  private generateModel(contentType: ContentTypeDefinition, registry: ContentTypeRegistry): string {
    const modelName = this.getModelName(contentType)
    const tableName = contentType.options?.tableName || contentType.pluralName

    let schema = `model ${modelName} {\n`

    // Add id field (always present)
    schema += `  id        Int      @id @default(autoincrement())\n`

    // Add custom fields
    for (const [fieldName, field] of Object.entries(contentType.fields)) {
      const fieldSchema = this.generateField(fieldName, field, contentType, registry)
      if (fieldSchema) {
        schema += fieldSchema
      }
    }

    // Add timestamps if enabled (default: true)
    if (contentType.options?.timestamps !== false) {
      schema += `  createdAt DateTime @default(now())\n`
      schema += `  updatedAt DateTime @updatedAt\n`
    }

    // Add soft delete if enabled
    if (contentType.options?.softDelete) {
      schema += `  deletedAt DateTime?\n`
    }

    schema += `\n`

    // Add table name mapping if custom
    if (contentType.options?.tableName) {
      schema += `  @@map("${tableName}")\n`
    }

    schema += `}`

    return schema
  }

  /**
   * Generate a field definition
   */
  private generateField(
    fieldName: string,
    field: Field,
    contentType: ContentTypeDefinition,
    registry: ContentTypeRegistry
  ): string {
    switch (field.type) {
      case 'string':
      case 'email':
      case 'password':
      case 'uid':
        return this.generateStringField(fieldName, field)
      case 'text':
      case 'richtext':
        return this.generateTextField(fieldName, field)
      case 'integer':
        return this.generateIntField(fieldName, field)
      case 'biginteger':
        return this.generateBigIntField(fieldName, field)
      case 'float':
      case 'decimal':
        return this.generateFloatField(fieldName, field)
      case 'boolean':
        return this.generateBooleanField(fieldName, field)
      case 'date':
      case 'datetime':
        return this.generateDateField(fieldName, field)
      case 'time':
        return this.generateTimeField(fieldName, field)
      case 'json':
        return this.generateJsonField(fieldName, field)
      case 'enumeration':
        return this.generateEnumField(fieldName, field, contentType)
      case 'relation':
        return this.generateRelationField(fieldName, field, contentType, registry)
      default: {
        const exhaustiveCheck: never = field
        console.warn(`Unknown field type: ${(exhaustiveCheck as any).type}`)
        return ''
      }
    }
  }

  private generateStringField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const unique = field.unique ? ' @unique' : ''
    const defaultValue = field.default ? ` @default("${field.default}")` : ''
    return `  ${fieldName}  String${optional}${unique}${defaultValue}\n`
  }

  private generateTextField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const defaultValue = field.default ? ` @default("${field.default}")` : ''
    return `  ${fieldName}  String${optional}${defaultValue}\n`
  }

  private generateIntField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const unique = field.unique ? ' @unique' : ''
    const defaultValue = field.default !== undefined ? ` @default(${field.default})` : ''
    return `  ${fieldName}  Int${optional}${unique}${defaultValue}\n`
  }

  private generateBigIntField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const unique = field.unique ? ' @unique' : ''
    const defaultValue = field.default !== undefined ? ` @default(${field.default})` : ''
    return `  ${fieldName}  BigInt${optional}${unique}${defaultValue}\n`
  }

  private generateFloatField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const defaultValue = field.default !== undefined ? ` @default(${field.default})` : ''
    return `  ${fieldName}  Float${optional}${defaultValue}\n`
  }

  private generateBooleanField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const defaultValue = field.default !== undefined ? ` @default(${field.default})` : ''
    return `  ${fieldName}  Boolean${optional}${defaultValue}\n`
  }

  private generateDateField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    const defaultValue =
      field.default === 'now' ? ' @default(now())' : field.default ? ` @default(${field.default})` : ''
    return `  ${fieldName}  DateTime${optional}${defaultValue}\n`
  }

  private generateTimeField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    return `  ${fieldName}  DateTime${optional}\n`
  }

  private generateJsonField(fieldName: string, field: Field): string {
    const optional = !field.required ? '?' : ''
    return `  ${fieldName}  Json${optional}\n`
  }

  private generateEnumField(fieldName: string, field: Field, contentType: ContentTypeDefinition): string {
    if (field.type !== 'enumeration') return ''

    const enumName = this.capitalize(this.getModelName(contentType)) + this.capitalize(fieldName)
    const optional = !field.required ? '?' : ''
    const defaultValue = field.default ? ` @default(${field.default})` : ''

    // Note: Enums need to be defined separately in Prisma
    return `  ${fieldName}  ${enumName}${optional}${defaultValue}\n`
  }

  private generateRelationField(
    fieldName: string,
    field: Field,
    contentType: ContentTypeDefinition,
    registry: ContentTypeRegistry
  ): string {
    if (field.type !== 'relation') return ''

    const targetModel = this.getModelNameFromUid(field.target, registry)
    const relationType = field.relationType

    switch (relationType) {
      case 'oneToOne':
        return this.generateOneToOneRelation(fieldName, field, targetModel)
      case 'oneToMany':
        return this.generateOneToManyRelation(fieldName, field, targetModel)
      case 'manyToOne':
        return this.generateManyToOneRelation(fieldName, field, targetModel, contentType)
      case 'manyToMany':
        return this.generateManyToManyRelation(fieldName, field, targetModel)
      default:
        return ''
    }
  }

  private generateOneToOneRelation(fieldName: string, field: Field, targetModel: string): string {
    const optional = !field.required ? '?' : ''
    return `  ${fieldName}   ${targetModel}${optional}\n`
  }

  private generateOneToManyRelation(fieldName: string, _field: Field, targetModel: string): string {
    return `  ${fieldName}   ${targetModel}[]\n`
  }

  private generateManyToOneRelation(
    fieldName: string,
    field: Field,
    targetModel: string,
    _contentType: ContentTypeDefinition
  ): string {
    const foreignKeyName = `${fieldName}Id`
    const optional = !field.required ? '?' : ''

    let schema = `  ${foreignKeyName} Int${optional}\n`
    schema += `  ${fieldName}   ${targetModel}${optional} @relation(fields: [${foreignKeyName}], references: [id])\n`

    return schema
  }

  private generateManyToManyRelation(fieldName: string, _field: Field, targetModel: string): string {
    return `  ${fieldName}   ${targetModel}[]\n`
  }

  /**
   * Get Prisma model name from content type
   */
  private getModelName(contentType: ContentTypeDefinition): string {
    return this.capitalize(contentType.singularName)
  }

  /**
   * Get model name from UID
   */
  private getModelNameFromUid(uid: string, registry: ContentTypeRegistry): string {
    const contentType = registry[uid]
    if (!contentType) {
      throw new Error(`Content type with uid ${uid} not found`)
    }
    return this.getModelName(contentType)
  }

  /**
   * Capitalize first letter
   */
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }

  /**
   * Generate enum definitions for all enumeration fields
   */
  generateEnums(contentTypes: ContentTypeRegistry): string {
    const enums: string[] = []

    for (const contentType of Object.values(contentTypes)) {
      for (const [fieldName, field] of Object.entries(contentType.fields)) {
        if (field.type === 'enumeration') {
          const enumName = this.capitalize(this.getModelName(contentType)) + this.capitalize(fieldName)
          let enumDef = `enum ${enumName} {\n`

          for (const value of field.values) {
            enumDef += `  ${value}\n`
          }

          enumDef += `}`
          enums.push(enumDef)
        }
      }
    }

    return enums.length > 0 ? '\n' + enums.join('\n\n') + '\n' : ''
  }
}

export const prismaSchemaGenerator = new PrismaSchemaGenerator()
